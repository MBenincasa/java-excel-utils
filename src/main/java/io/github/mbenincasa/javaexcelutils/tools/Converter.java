package io.github.mbenincasa.javaexcelutils.tools;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.github.mbenincasa.javaexcelutils.annotations.ExcelBodyStyle;
import io.github.mbenincasa.javaexcelutils.annotations.ExcelField;
import io.github.mbenincasa.javaexcelutils.annotations.ExcelHeaderStyle;
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;
import com.opencsv.exceptions.CsvValidationException;
import io.github.mbenincasa.javaexcelutils.enums.Extension;
import io.github.mbenincasa.javaexcelutils.exceptions.*;
import io.github.mbenincasa.javaexcelutils.model.converter.ExcelToObject;
import io.github.mbenincasa.javaexcelutils.model.converter.JsonToExcel;
import io.github.mbenincasa.javaexcelutils.model.converter.ObjectToExcel;
import io.github.mbenincasa.javaexcelutils.model.excel.ExcelCell;
import io.github.mbenincasa.javaexcelutils.model.excel.ExcelRow;
import io.github.mbenincasa.javaexcelutils.model.excel.ExcelSheet;
import io.github.mbenincasa.javaexcelutils.model.excel.ExcelWorkbook;
import org.apache.commons.io.FilenameUtils;
import org.apache.poi.ss.usermodel.*;

import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

/**
 * {@code Converter} is the static class with implementations of conversion methods
 * @author Mirko Benincasa
 * @since 0.2.0
 */
public class Converter {

    /**
     * @param objectToExcels A list of {@code ObjectToExcels}. Each element represents a Sheet
     * @param extension The extension to assign to the Excel file
     * @param filename The name, including the path, to be associated with the File.<p> Note: Do not add the extension
     * @param writeHeader If {@code true} it will write the header to the first line
     * @return The Excel file generated by the conversion
     * @throws ExtensionNotValidException If the input file extension does not belong to an Excel file
     * @throws IOException If an I/O error has occurred
     * @throws FileAlreadyExistsException If the destination file already exists
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static File objectsToExcelFile(List<ObjectToExcel<?>> objectToExcels, Extension extension, String filename, Boolean writeHeader) throws ExtensionNotValidException, IOException, FileAlreadyExistsException, SheetAlreadyExistsException {
        File file = new File(filename + "." + extension.getExt());
        if (file.exists())
            throw new FileAlreadyExistsException("There is already a file with this pathname: " + file.getAbsolutePath());

        byte[] byteResult = objectsToExcelByte(objectToExcels, extension, writeHeader);
        FileOutputStream fileOutputStream = new FileOutputStream(file);
        fileOutputStream.write(byteResult);
        fileOutputStream.close();

        return file;
    }

    /**
     * @param objectToExcels A list of {@code ObjectToExcels}. Each element represents a Sheet
     * @param extension The extension to assign to the Excel file
     * @param writeHeader If {@code true} it will write the header to the first line
     * @return The Excel OutputStream generated by the conversion in the form of a byte array
     * @throws ExtensionNotValidException If the input file extension does not belong to an Excel file
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static byte[] objectsToExcelByte(List<ObjectToExcel<?>> objectToExcels, Extension extension, Boolean writeHeader) throws ExtensionNotValidException, IOException, SheetAlreadyExistsException {
        ByteArrayOutputStream outputStream = objectsToExcelStream(objectToExcels, extension, writeHeader);
        return outputStream.toByteArray();
    }

    /**
     * @param objectToExcels A list of {@code ObjectToExcels}. Each element represents a Sheet
     * @param extension The extension to assign to the Excel file
     * @param writeHeader If {@code true} it will write the header to the first line
     * @return The Excel OutputStream generated by the conversion in the form of a ByteArrayOutputStream
     * @throws ExtensionNotValidException If the input file extension does not belong to an Excel file
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static ByteArrayOutputStream objectsToExcelStream(List<ObjectToExcel<?>> objectToExcels, Extension extension, Boolean writeHeader) throws ExtensionNotValidException, IOException, SheetAlreadyExistsException {
        /* Check extension*/
        if(!extension.isExcelExtension())
            throw new ExtensionNotValidException("Select an extension for an Excel file");

        /* Create workbook */
        ExcelWorkbook excelWorkbook = ExcelWorkbook.create(extension);

        /* Create a Sheet for each element */
        for(ObjectToExcel<?> objectToExcel : objectToExcels) {
            ExcelSheet excelSheet = excelWorkbook.createSheet(objectToExcel.getSheetName());
            Class<?> clazz = objectToExcel.getClazz();
            Field[] fields = clazz.getDeclaredFields();
            setFieldsAccessible(fields);
            AtomicInteger nRow = new AtomicInteger();

            /* Write header */
            if (writeHeader) {
                CellStyle headerCellStyle = createHeaderCellStyle(excelWorkbook, clazz);
                ExcelRow headerRow = excelSheet.createRow(nRow.getAndIncrement());
                for (int i = 0; i < fields.length; i++) {
                    ExcelCell excelCell = headerRow.createCell(i);
                    excelCell.getCell().setCellStyle(headerCellStyle);
                    ExcelField excelField = fields[i].getAnnotation(ExcelField.class);
                    excelCell.writeValue(excelField != null ? excelField.name() : fields[i].getName());
                }
            }

            /* Write body */
            objectToExcel.getStream().forEach(object -> {
                CellStyle bodyCellStyle = createBodyStyle(excelWorkbook, clazz);
                ExcelRow excelRow = excelSheet.createRow(nRow.getAndIncrement());
                for (int i = 0; i < fields.length; i++) {
                    ExcelCell excelCell = excelRow.createCell(i);
                    excelCell.getCell().setCellStyle(bodyCellStyle);
                    try {
                        excelCell.writeValue(fields[i].get(object));
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    }
                }
            });

            /* Set auto-size columns */
            setAutoSizeColumn(excelSheet, fields, clazz);
        }

        /* Write and close */
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        excelWorkbook.writeAndClose(outputStream);
        return outputStream;
    }

    /**
     * @param bytes The byte array of the Excel file
     * @param excelToObjects A list of {@code ExcelToObject}. Each element represents a Sheet
     * @return A map where the key represents the name of the Sheet and the value the Stream of objects present in the sheet
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws SheetNotFoundException If the sheet to open is not found
     * @throws ReadValueException If an error occurs while reading a cell
     * @throws HeaderNotPresentException If the first row is empty and does not contain the header
     * @throws InvocationTargetException If an error occurs while instantiating a new object or setting a field
     * @throws NoSuchMethodException If the setting method or empty constructor of the object is not found
     * @throws InstantiationException f an error occurs while instantiating a new object
     * @throws IllegalAccessException If a field or fields of the {@code clazz} could not be accessed
     * @throws IOException If an I/O error occurs
     * @since 0.4.0
     */
    public static Map<String, Stream<?>> excelByteToObjects(byte[] bytes, List<ExcelToObject<?>> excelToObjects) throws OpenWorkbookException, SheetNotFoundException, ReadValueException, HeaderNotPresentException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, IOException {
        ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
        return excelStreamToObjects(byteStream, excelToObjects);
    }

    /**
     * @param file The Excel file
     * @param excelToObjects A list of {@code ExcelToObject}. Each element represents a Sheet
     * @return A map where the key represents the name of the Sheet and the value the Stream of objects present in the sheet
     * @throws IOException If an I/O error occurs
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws SheetNotFoundException If the sheet to open is not found
     * @throws ReadValueException If an error occurs while reading a cell
     * @throws HeaderNotPresentException If the first row is empty and does not contain the header
     * @throws InvocationTargetException If an error occurs while instantiating a new object or setting a field
     * @throws NoSuchMethodException If the setting method or empty constructor of the object is not found
     * @throws InstantiationException If an error occurs while instantiating a new object
     * @throws IllegalAccessException If a field or fields of the {@code clazz} could not be accessed
     * @throws ExtensionNotValidException If the input file extension does not belong to an Excel file
     * @since 0.4.0
     */
    public static Map<String, Stream<?>> excelFileToObjects(File file, List<ExcelToObject<?>> excelToObjects) throws IOException, OpenWorkbookException, SheetNotFoundException, ReadValueException, HeaderNotPresentException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException, ExtensionNotValidException {
        if (!ExcelUtility.isValidExcelExtension(FilenameUtils.getExtension(file.getName()))) {
            throw new ExtensionNotValidException("Pass a file with the XLS or XLSX extension");
        }
        FileInputStream fileInputStream = new FileInputStream(file);
        Map<String, Stream<?>> map = excelStreamToObjects(fileInputStream, excelToObjects);
        fileInputStream.close();
        return map;
    }

    /**
     * @param inputStream The InputStream of the Excel file
     * @param excelToObjects A list of {@code ExcelToObject}. Each element represents a Sheet
     * @return A map where the key represents the name of the Sheet and the value the Stream of objects present in the sheet
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws SheetNotFoundException If the sheet to open is not found
     * @throws HeaderNotPresentException If the first row is empty and does not contain the header
     * @throws NoSuchMethodException If the setting method or empty constructor of the object is not found
     * @throws InvocationTargetException If an error occurs while instantiating a new object or setting a field
     * @throws InstantiationException f an error occurs while instantiating a new object
     * @throws IllegalAccessException If a field or fields of the {@code clazz} could not be accessed
     * @throws ReadValueException If an error occurs while reading a cell
     * @throws IOException If an I/O error occurs
     * @since 0.4.0
     */
    public static Map<String, Stream<?>> excelStreamToObjects(InputStream inputStream, List<ExcelToObject<?>> excelToObjects) throws OpenWorkbookException, SheetNotFoundException, HeaderNotPresentException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, ReadValueException, IOException {
        /* Open Workbook */
        ExcelWorkbook excelWorkbook = ExcelWorkbook.open(inputStream);
        Map<String, Stream<?>> map = new HashMap<>();

        /* Iterate all the sheets to convert */
        for (ExcelToObject<?> excelToObject : excelToObjects) {
            Class<?> clazz = excelToObject.getClazz();
            ExcelSheet excelSheet = excelWorkbook.getSheet(excelToObject.getSheetName());

            /* Retrieving header names */
            Field[] fields = clazz.getDeclaredFields();
            setFieldsAccessible(fields);
            Map<Integer, String> headerMap = getHeaderNames(excelSheet, fields);

            Stream.Builder<Object> streamBuilder = Stream.builder();

            /* Iterate all rows */
            for (ExcelRow excelRow : excelSheet.getRows()) {
                if (excelRow.getRow() == null || excelRow.getIndex() == 0) {
                    continue;
                }

                Object obj = clazz.getDeclaredConstructor().newInstance();
                /* Iterate all cells */
                for (ExcelCell excelCell : excelRow.getCells()) {
                    if (excelCell.getCell() == null) {
                        continue;
                    }

                    String headerName = headerMap.get(excelCell.getIndex());
                    if (headerName == null || headerMap.isEmpty()) {
                        continue;
                    }

                    /* Read the value in the cell */
                    Optional<Field> fieldOptional = Arrays.stream(fields).filter(f -> f.getName().equalsIgnoreCase(headerName)).findFirst();
                    if (fieldOptional.isEmpty()) {
                        throw new RuntimeException();
                    }
                    Field field = fieldOptional.get();

                    /* Set the value */
                    String methodName = "set" + Character.toUpperCase(headerName.charAt(0)) + headerName.substring(1);
                    Method setMethod = clazz.getMethod(methodName, field.getType());
                    setMethod.invoke(obj, excelCell.readValue(field.getType()));
                }
                /* Adds the object to the Stream after it has finished cycling through all cells */
                streamBuilder.add(obj);
            }
            /* inserts the Stream of all Sheet objects into the Map */
            map.put(excelSheet.getName(), streamBuilder.build());
        }

        excelWorkbook.close(inputStream);
        return map;
    }

    /**
     * @param bytes The Excel file in the form of a byte array
     * @return A map where the key represents the Sheet name and the value is a CSV file for each Sheet
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws IOException If an I/O error has occurred
     * @since 0.4.0
     */
    public static Map<String, byte[]> excelToCsvByte(byte[] bytes) throws OpenWorkbookException, IOException {
        /* Open InputStream */
        InputStream inputStream = new ByteArrayInputStream(bytes);
        Map<String, byte[]> byteArrayMap = new HashMap<>();

        Map<String, ByteArrayOutputStream> outputStreamMap = excelToCsvStream(inputStream);

        /* iterate all the outputStream */
        for (Map.Entry<String, ByteArrayOutputStream> entry : outputStreamMap.entrySet()) {
            ByteArrayOutputStream baos = entry.getValue();
            byteArrayMap.put(entry.getKey(), baos.toByteArray());
        }

        return byteArrayMap;
    }

    /**
     * @param excelFile The Excel file
     * @param path The path, without file name, where the files will be saved
     * @return A map where the key represents the Sheet name and the value is a CSV file for each Sheet
     * @throws IOException If an I/O error has occurred
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws ExtensionNotValidException If an extension is not correct
     * @since 0.4.0
     */
    public static Map<String, File> excelToCsvFile(File excelFile, String path) throws IOException, OpenWorkbookException, ExtensionNotValidException {
        if (!ExcelUtility.isValidExcelExtension(FilenameUtils.getExtension(excelFile.getName()))) {
            throw new ExtensionNotValidException("Pass a file with the XLS or XLSX extension");
        }
        /* Open InputStream */
        FileInputStream fileInputStream = new FileInputStream(excelFile);
        Map<String, File> fileMap = new HashMap<>();

        Map<String, ByteArrayOutputStream> outputStreamMap = excelToCsvStream(fileInputStream);

        /* iterate all the outputStream */
        for (Map.Entry<String, ByteArrayOutputStream> entry : outputStreamMap.entrySet()) {
            String pathname = path + "/" + entry.getKey() + "." + Extension.CSV.getExt();
            FileOutputStream fileOutputStream = new FileOutputStream(pathname);
            ByteArrayOutputStream baos = entry.getValue();
            fileOutputStream.write(baos.toByteArray());
            File file = new File(pathname);
            fileMap.put(entry.getKey(), file);
            fileOutputStream.close();
        }

        return fileMap;
    }

    /**
     * @param excelInputStream The Excel file in the form of an InputStream
     * @return A map where the key represents the Sheet name and the value is a CSV file for each Sheet
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws IOException If an I/O error has occurred
     * @since 0.4.0
     */
    public static Map<String, ByteArrayOutputStream> excelToCsvStream(InputStream excelInputStream) throws OpenWorkbookException, IOException {
        /* Open file excel */
        ExcelWorkbook excelWorkbook = ExcelWorkbook.open(excelInputStream);
        List<ExcelSheet> excelSheets = excelWorkbook.getSheets();

        Map<String, ByteArrayOutputStream> map = new HashMap<>();

        /* Iterate all the Sheets */
        for (ExcelSheet excelSheet : excelSheets) {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

            /* Open CSV Writer */
            Writer writer = new OutputStreamWriter(outputStream);
            CSVWriter csvWriter = new CSVWriter(writer);

            for (ExcelRow excelRow : excelSheet.getRows()) {
                List<String> data = new LinkedList<>();
                for (ExcelCell excelCell : excelRow.getCells()) {
                    data.add(excelCell.readValueAsString());
                }
                csvWriter.writeNext(data.toArray(data.toArray(new String[0])));
            }
            csvWriter.close();
            map.put(excelSheet.getName(), outputStream);
        }

        /* Close workbook */
        excelWorkbook.close(excelInputStream);

        return map;
    }

    /**
     * @param bytes The CSV file in the form of a byte array
     * @param sheetName The name of the sheet to create
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @return The Excel file in the form of a byte array
     * @throws CsvValidationException If the CSV file has invalid formatting
     * @throws ExtensionNotValidException If an extension is not correct
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static byte[] csvToExcelByte(byte[] bytes, String sheetName, Extension extension) throws CsvValidationException, ExtensionNotValidException, IOException, SheetAlreadyExistsException {
        InputStream inputStream = new ByteArrayInputStream(bytes);
        ByteArrayOutputStream baos = csvToExcelStream(inputStream, sheetName, extension);
        return baos.toByteArray();
    }

    /**
     * @param fileInput The CSV file
     * @param sheetName The name of the sheet to create
     * @param pathname The path with the file name. Note: Do not add the extension
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @return The Excel file
     * @throws IOException If an I/O error has occurred
     * @throws CsvValidationException If the CSV file has invalid formatting
     * @throws ExtensionNotValidException If an extension is not correct
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static File csvToExcelFile(File fileInput, String sheetName, String pathname, Extension extension) throws IOException, CsvValidationException, ExtensionNotValidException, SheetAlreadyExistsException {
        isValidCsvExtension(FilenameUtils.getExtension(fileInput.getName()));
        InputStream inputStream = new FileInputStream(fileInput);
        ByteArrayOutputStream baos = csvToExcelStream(inputStream, sheetName, extension);
        pathname = pathname + "." + extension.getExt();
        FileOutputStream fileOutputStream = new FileOutputStream(pathname);
        fileOutputStream.write(baos.toByteArray());
        File file = new File(pathname);
        fileOutputStream.close();

        return file;
    }

    /**
     * @param inputStream The CSV file in the form of a InputStream
     * @param sheetName The name of the sheet to create
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @return The Excel file in the form of a ByteArrayOutputStream
     * @throws ExtensionNotValidException If an extension is not correct
     * @throws CsvValidationException If the CSV file has invalid formatting
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static ByteArrayOutputStream csvToExcelStream(InputStream inputStream, String sheetName, Extension extension) throws ExtensionNotValidException, CsvValidationException, IOException, SheetAlreadyExistsException {
        /* Check the extension */
        if (!ExcelUtility.isValidExcelExtension(extension.getExt())) {
            throw new ExtensionNotValidException("Pass a file with the XLS or XLSX extension");
        }

        /* Open CSV Reader */
        Reader reader = new InputStreamReader(inputStream);
        CSVReader csvReader = new CSVReader(reader);

        ExcelWorkbook excelWorkbook = ExcelWorkbook.create(extension);
        ExcelSheet excelSheet = excelWorkbook.createSheet(sheetName);

        /* Read CSV file */
        String[] values;
        int cRow = 0;
        while ((values = csvReader.readNext()) != null) {
            ExcelRow excelRow = excelSheet.createRow(cRow);
            for (int j = 0; j < values.length; j++) {
                ExcelCell excelCell = excelRow.createCell(j);
                excelCell.writeValue(values[j]);
                excelSheet.getSheet().autoSizeColumn(j);
            }
            cRow++;
        }

        /* Write and close the Workbook */
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        inputStream.close();
        excelWorkbook.writeAndClose(outputStream);
        csvReader.close();

        return outputStream;
    }

    /**
     * @param bytes The Excel file in the form of a byte array
     * @return The Json file in the form of a byte array
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws IOException If an I/O error has occurred
     * @since 0.4.0
     */
    public static byte[] excelToJsonByte(byte[] bytes) throws OpenWorkbookException, IOException {
        InputStream inputStream = new ByteArrayInputStream(bytes);
        ByteArrayOutputStream baos = excelToJsonStream(inputStream);
        return baos.toByteArray();
    }

    /**
     * @param excelFile The Excel file
     * @param pathname The path with the file name. Note: Do not add the extension
     * @return The Json file
     * @throws IOException If an I/O error has occurred
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws ExtensionNotValidException If the extension is incorrect
     * @since 0.4.0
     */
    public static File excelToJsonFile(File excelFile, String pathname) throws IOException, OpenWorkbookException, ExtensionNotValidException {
        if (!ExcelUtility.isValidExcelExtension(FilenameUtils.getExtension(excelFile.getName()))) {
            throw new ExtensionNotValidException("Pass a file with the XLS or XLSX extension");
        }
        FileInputStream fileInputStream = new FileInputStream(excelFile);
        ByteArrayOutputStream baos = excelToJsonStream(fileInputStream);
        pathname = pathname + "." + Extension.JSON.getExt();
        FileOutputStream fileOutputStream = new FileOutputStream(pathname);
        fileOutputStream.write(baos.toByteArray());
        File jsonFile = new File(pathname);
        fileOutputStream.close();

        return jsonFile;
    }

    /**
     * @param excelInputStream The Excel file in the form of an InputStream
     * @return The Json file in the form of a ByteArrayOutputStream
     * @throws OpenWorkbookException If an error occurred while opening the workbook
     * @throws IOException If an I/O error has occurred
     * @since 0.4.0
     */
    public static ByteArrayOutputStream excelToJsonStream(InputStream excelInputStream) throws OpenWorkbookException, IOException {
        /* Open Workbook */
        ExcelWorkbook excelWorkbook = ExcelWorkbook.open(excelInputStream);
        List<ExcelSheet> excelSheets = excelWorkbook.getSheets();

        /* Create Json Object */
        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode rootNode = objectMapper.createObjectNode();

        /* Iterate all the Sheets */
        for (ExcelSheet excelSheet : excelSheets) {
            /* Create a node for each Sheet */
            ObjectNode sheetNode = objectMapper.createObjectNode();
            List<ExcelRow> excelRows = excelSheet.getRows();

            /* Iterate all the Rows */
            for (ExcelRow excelRow : excelRows) {
                /* Create a node for each Row */
                ObjectNode rowNode = objectMapper.createObjectNode();
                List<ExcelCell> excelCells = excelRow.getCells();

                /* Iterate all the Cells */
                for (ExcelCell excelCell : excelCells) {
                    rowNode.put("col_" + (excelCell.getIndex() + 1), excelCell.readValueAsString());
                }
                sheetNode.putPOJO("row_" + (excelRow.getIndex() + 1), rowNode);
            }

            rootNode.putPOJO(excelSheet.getName(), sheetNode);
        }

        /* Close Workbook */
        excelWorkbook.close(excelInputStream);

        /* Create OutputStream */
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        objectMapper.writeValue(byteArrayOutputStream, rootNode);

        return byteArrayOutputStream;
    }

    /**
     * @param bytes The Json file in the form of a byte array. Note: Must be formatted as an array of objects
     * @param jsonToExcel It is used to convert Json elements into objects
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @param writeHeader If {@code true} it will write the header to the first line
     * @param <T> The class parameter of the object
     * @return The Excel file in the form of a byte array
     * @throws ExtensionNotValidException If the extension is incorrect
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static <T> byte[] jsonToExcelByte(byte[] bytes, JsonToExcel<T> jsonToExcel, Extension extension, Boolean writeHeader) throws ExtensionNotValidException, IOException, SheetAlreadyExistsException {
        InputStream inputStream = new ByteArrayInputStream(bytes);
        return jsonToExcelStream(inputStream, jsonToExcel, extension, writeHeader).toByteArray();
    }

    /**
     * @param jsonFile The Json file. Note: Must be formatted as an array of objects
     * @param jsonToExcel It is used to convert Json elements into objects
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @param filename File name, including path, to specify where to save. Note: Do not add the extension
     * @param writeHeader If {@code true} it will write the header to the first line
     * @param <T> The class parameter of the object
     * @return The Excel file
     * @throws IOException If an I/O error has occurred
     * @throws ExtensionNotValidException If the extension is incorrect
     * @throws FileAlreadyExistsException If the destination file already exists
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static <T> File jsonToExcelFile(File jsonFile, JsonToExcel<T> jsonToExcel, Extension extension, String filename, Boolean writeHeader) throws IOException, ExtensionNotValidException, FileAlreadyExistsException, SheetAlreadyExistsException {
        /* Check extension */
        isValidJsonExtension(FilenameUtils.getExtension(jsonFile.getName()));
        FileInputStream fileInputStream = new FileInputStream(jsonFile);

        /* Convert the Json to a Stream */
        List<ObjectToExcel<?>> objectToExcels = jsonInputStreamToObjectToExcel(fileInputStream, jsonToExcel);
        fileInputStream.close();

        /* Call the method that converts objects to in Excel */
        return objectsToExcelFile(objectToExcels, extension, filename, writeHeader);
    }

    /**
     * @param jsonStream The Json file in the form of an InputStream. Note: Must be formatted as an array of objects
     * @param jsonToExcel It is used to convert Json elements into objects
     * @param extension The extension of the output file. Select an extension with {@code type} EXCEL
     * @param writeHeader If {@code true} it will write the header to the first line
     * @param <T> The class parameter of the object
     * @return The Excel file in the form of a ByteArrayOutputStream
     * @throws ExtensionNotValidException If the extension is incorrect
     * @throws IOException If an I/O error has occurred
     * @throws SheetAlreadyExistsException If you try to insert a Sheet that already exists
     * @since 0.4.0
     */
    public static <T> ByteArrayOutputStream jsonToExcelStream(InputStream jsonStream, JsonToExcel<T> jsonToExcel, Extension extension, Boolean writeHeader) throws ExtensionNotValidException, IOException, SheetAlreadyExistsException {
        /* Check extension */
        if(!extension.isExcelExtension())
            throw new ExtensionNotValidException("Select an extension for an Excel file");

        /* Convert the Json to a Stream */
        List<ObjectToExcel<?>> objectToExcels = jsonInputStreamToObjectToExcel(jsonStream, jsonToExcel);

        /* Call the method that converts objects to in Excel */
        return objectsToExcelStream(objectToExcels, extension, writeHeader);
    }

    private static <T> List<ObjectToExcel<?>> jsonInputStreamToObjectToExcel(InputStream jsonStream, JsonToExcel<T> jsonToExcel) throws IOException {
        Stream<T> jsonObjectsStream = jsonToStream(jsonStream, jsonToExcel.getClazz());
        ObjectToExcel<T> objectToExcel = new ObjectToExcel<>(jsonToExcel.getSheetName(), jsonToExcel.getClazz(), jsonObjectsStream);
        List<ObjectToExcel<?>> objectToExcels = new ArrayList<>();
        objectToExcels.add(objectToExcel);

        return objectToExcels;
    }

    private static <T> Stream<T> jsonToStream(InputStream inputStream, Class<T> clazz) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        JsonParser jsonParser = objectMapper.getFactory().createParser(inputStream);
        TypeReference<List<T>> typeRef = new TypeReference<>() {};
        List<T> hashList = objectMapper.readValue(jsonParser, typeRef);
        List<T> list = new ArrayList<>();
        for (T val : hashList) {
            T obj = objectMapper.convertValue(val, clazz);
            list.add(obj);
        }
        return list.stream();
    }

    private static void isValidCsvExtension(String extension) throws ExtensionNotValidException {
        if (!extension.equalsIgnoreCase(Extension.CSV.getExt()))
            throw new ExtensionNotValidException("Pass a file with the CSV extension");
    }

    private static void isValidJsonExtension(String extension) throws ExtensionNotValidException {
        if (!extension.equalsIgnoreCase(Extension.JSON.getExt()))
            throw new ExtensionNotValidException("Pass a file with the JSON extension");
    }

    private static Map<Integer, String> getHeaderNames(ExcelSheet excelSheet, Field[] fields) throws HeaderNotPresentException {
        Map<String, String> fieldNames = new HashMap<>();
        for (Field field : fields) {
            ExcelField excelField = field.getAnnotation(ExcelField.class);
            fieldNames.put(excelField == null ? field.getName() : excelField.name(), field.getName());
        }

        Row headerRow = excelSheet.getSheet().getRow(0);
        if (headerRow == null)
            throw new HeaderNotPresentException("There is no header in the first row of the sheet.");

        Map<Integer, String> headerMap = new TreeMap<>();
        for (Cell cell : headerRow) {
            if (fieldNames.containsKey(cell.getStringCellValue())) {
                headerMap.put(cell.getColumnIndex(), fieldNames.get(cell.getStringCellValue()));
            }
        }

        return headerMap;
    }

    private static void setFieldsAccessible(Field[] fields) {
        for (Field field : fields) {
            field.setAccessible(true);
        }
    }

    private static CellStyle createHeaderCellStyle(ExcelWorkbook excelWorkbook, Class<?> clazz) {
        CellStyle cellStyle = excelWorkbook.getWorkbook().createCellStyle();
        ExcelHeaderStyle excelHeaderStyle = clazz.getAnnotation(ExcelHeaderStyle.class);
        if (excelHeaderStyle == null) {
            return cellStyle;
        }
        return createCellStyle(cellStyle, excelHeaderStyle.cellColor(), excelHeaderStyle.horizontal(), excelHeaderStyle.vertical());
    }

    private static CellStyle createBodyStyle(ExcelWorkbook excelWorkbook, Class<?> clazz) {
        CellStyle cellStyle = excelWorkbook.getWorkbook().createCellStyle();
        ExcelBodyStyle excelBodyStyle = clazz.getAnnotation(ExcelBodyStyle.class);
        if (excelBodyStyle == null) {
            return cellStyle;
        }
        return createCellStyle(cellStyle, excelBodyStyle.cellColor(), excelBodyStyle.horizontal(), excelBodyStyle.vertical());
    }

    private static CellStyle createCellStyle(CellStyle cellStyle, IndexedColors indexedColors, HorizontalAlignment horizontal, VerticalAlignment vertical) {
        cellStyle.setFillForegroundColor(indexedColors.getIndex());
        cellStyle.setFillPattern(FillPatternType.BIG_SPOTS);
        cellStyle.setAlignment(horizontal);
        cellStyle.setVerticalAlignment(vertical);
        cellStyle.setBorderBottom(BorderStyle.MEDIUM);

        return cellStyle;
    }

    private static void setAutoSizeColumn(ExcelSheet excelSheet, Field[] fields, Class<?> clazz) {
        ExcelHeaderStyle excelHeaderStyle = clazz.getAnnotation(ExcelHeaderStyle.class);
        if (excelHeaderStyle != null && excelHeaderStyle.autoSize()) {
            for (int i = 0; i < fields.length; i++) {
                excelSheet.getSheet().autoSizeColumn(i);
            }
        }
    }
}
